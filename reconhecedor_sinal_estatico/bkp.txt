/*#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/ml/ml.hpp>
#include <iostream>
#include <string>

using namespace cv;
using namespace std;

int main()
{
    Mat rawTreinamento;
	cv::FileStorage file("treinamento1_esq.xml", FileStorage::READ);
	file["MaoEsquerda"] >> rawTreinamento;

	if (!file.isOpened()) {
		printf("\n aeheauheua");
	}

	int area = 140*140;
	Mat dadosTreinamento(2, area, CV_32FC1);

	int i,j,k=0;
	for(i = 0; i < rawTreinamento.rows; i++) {
		for (j = 0; j < rawTreinamento.cols; j++) {
			float B = 0;
			float G = rawTreinamento.at<Vec3b>(i, j)[1];
			float R = rawTreinamento.at<Vec3b>(i, j)[2];
			dadosTreinamento.at<float>(1,k) = B;
			dadosTreinamento.at<float>(0,k++) = (R+G);
		}
	}

	float label[2] = {1.0, -1.0};
	Mat labelTreinamento(2, 1, CV_32FC1, label); 
//system("PAUSE");
    
	CvSVMParams params;
    params.svm_type    = CvSVM::C_SVC;
    params.kernel_type = CvSVM::LINEAR;
    params.term_crit   = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);

	//printf("%d %d", dadosTreinamento.size(), labelTreinamento.size());
//	system("PAUSE");
    CvSVM SVM;
    SVM.train(dadosTreinamento, labelTreinamento, Mat(), Mat(), params);
	
	Mat teste(1, area, CV_32FC1);
	Mat teste2(1, area, CV_32FC1);
	k = 0;
	for(i = 0; i < rawTreinamento.rows; i++) {
		for (j = 0; j < rawTreinamento.cols; j++) {
			float B = 0;
			float G = rawTreinamento.at<Vec3b>(i, j)[1];
			float R = rawTreinamento.at<Vec3b>(i, j)[2];
			teste2.at<float>(0,k) = B;
			teste.at<float>(0,k++) = (R+G);
		}
	}

	float response = SVM.predict(teste);
	cout << response << endl;
	response = SVM.predict(teste2);
	cout << response << endl;
	system("PAUSE");
	/*
    // Set up training data
    float labels[4] = {1.0, -1.0, -1.0, -1.0};
    Mat labelsMat(4, 1, CV_32FC1, labels);
	//float trainingData[4][2] = { {501, 10}, {255, 10}, {501, 255}, {10, 501} };
    //Mat trainingDataMat(4, 2, CV_32FC1, trainingData);

    // Set up SVM's parameters
    CvSVMParams params;
    params.svm_type    = CvSVM::C_SVC;
    params.kernel_type = CvSVM::LINEAR;
    params.term_crit   = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);

    // Train the SVM
    CvSVM SVM;
    SVM.train(trainingDataMat, labelsMat, Mat(), Mat(), params);

    Vec3b green(0,255,0), blue (255,0,0);
    // Show the decision regions given by the SVM
    for (int i = 0; i < image.rows; ++i)
        for (int j = 0; j < image.cols; ++j)
        {
            Mat sampleMat = (Mat_<float>(1,2) << j,i);
            float response = SVM.predict(sampleMat);

            if (response == 1)
                image.at<Vec3b>(i,j)  = green;
            else if (response == -1)
                 image.at<Vec3b>(i,j)  = blue;
        }

    // Show the training data
    int thickness = -1;
    int lineType = 8;
    circle( image, Point(501,  10), 5, Scalar(  0,   0,   0), thickness, lineType);
    circle( image, Point(255,  10), 5, Scalar(255, 255, 255), thickness, lineType);
    circle( image, Point(501, 255), 5, Scalar(255, 255, 255), thickness, lineType);
    circle( image, Point( 10, 501), 5, Scalar(255, 255, 255), thickness, lineType);

    // Show support vectors
    thickness = 2;
    lineType  = 8;
    int c     = SVM.get_support_vector_count();

    for (int i = 0; i < c; ++i)
    {
        const float* v = SVM.get_support_vector(i);
        circle( image,  Point( (int) v[0], (int) v[1]),   6,  Scalar(128, 128, 128), thickness, lineType);
    }

    imwrite("result.png", image);        // save the image

    imshow("SVM Simple Example", image); // show it to the user
    waitKey(0);

}*/



				/*Mat handCpy = handMat.clone();
				std::vector< std::vector<Point> > contours;
				//findContours(handCpy, contours, CV_RETR_EXTERNAL,CV_CHAIN_APPROX_NONE);
				findContours(handCpy, contours, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);
				if (contours.size()) {
					for (int i = 0; i < contours.size(); i++) {
						vector<Point> contour = contours[i];
						Mat contourMat = Mat(contour);
						double cArea = contourArea(contourMat);

						if(cArea > 3000) // likely the hand
						{
							Scalar center = mean(contourMat);
							//Point centerPoint = Point(center.val[0], center.val[1]);

							// approximate the contour by a simple curve
							vector<Point> approxCurve;
							approxPolyDP(contourMat, approxCurve, 10, true);

							//vector< vector<Point> > debugContourV;
							//debugContourV.push_back(approxCurve);
							//drawContours(debugFrames[indiceMao], debugContourV, 0, COLOR_DARK_GREEN, 2);

							vector<int> hull;
							convexHull(Mat(approxCurve), hull, false, false);

							// draw the hull points
							//for(int j = 0; j < hull.size(); j++)
							//{
							//   int index = hull[j];
							//    circle(debugFrames[indiceMao], approxCurve[index], 3, COLOR_YELLOW, 2);
							//}

							// find convexity defects
							vector<ConvexityDefect> convexDefects;
							findConvexityDefects(approxCurve, hull, convexDefects);
							//printf("Number of defects: %d.\n", (int) convexDefects.size());

							//for(int j = 0; j < convexDefects.size(); j++)
							//{
								//circle(debugFrames[indiceMao], convexDefects[j].depth_point, 3, COLOR_BLUE, 2);

							//}
                        
							// assemble point set of convex hull
							vector<Point> hullPoints;
							for(int k = 0; k < hull.size(); k++)
							{
								int curveIndex = hull[k];
								Point p = approxCurve[curveIndex];
								hullPoints.push_back(p);
							}

							// area of hull and curve
							double hullArea  = contourArea(Mat(hullPoints));
							double curveArea = contourArea(Mat(approxCurve));
							double handRatio = curveArea/hullArea;
							//printf("\n %d", handRatio);
							// hand is grasping
							if(handRatio <= GRASPING_THRESH && convexDefects.size() > 0)
								//circle(debugFrames[indiceMao], centerPoint, 5, COLOR_LIGHT_GREEN, 5);
								printf("\nOOOOOOOOOOOOOOOO %d | %d", convexDefects.size(), hull.size());
								//circle(debugFrames[indiceMao], centerPoint, 5, COLOR_RED, 5);
						}
					} // contour conditional
				} // hands loop*/